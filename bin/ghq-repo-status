#!/usr/bin/env bash
set -o errexit
set -o nounset
set -o pipefail
set -o posix

# Display status of all ghq-managed repositories.
# Shows branch name, untracked files, modified files, and diff statistics.
#
# Usage:
#   ghq-repo-status
#
# Output format:
#   github.com/org/repo (branch) [W][M] ?N ~N +N -N
#     [W] = Worktree
#     [M] = Merged to main/master
#     ?N  = Untracked files count
#     ~N  = Modified files count
#     +N  = Insertions count
#     -N  = Deletions count
#
# Dependencies:
#   - ghq

# Number of parallel jobs (adjust as needed)
PARALLEL_JOBS=1

# Get ghq root path once at script start
GHQ_ROOT_RAW=$(ghq root 2>/dev/null)
if [[ -z $GHQ_ROOT_RAW ]]; then
  echo "Error: Could not determine ghq root. Make sure ghq is installed and configured." >&2
  exit 1
fi

# Ensure trailing slash for path operations
GHQ_ROOT="$GHQ_ROOT_RAW"
[[ $GHQ_ROOT != */ ]] && GHQ_ROOT="$GHQ_ROOT/"

# Get repository status information
get_repo_status_info() {
  local repo_full_path="$1"

  # Generate short repository name from full path
  local repo_short_name="${repo_full_path#"$GHQ_ROOT"}"

  # Get all status info at once with git status --porcelain=v1
  local git_status_output
  git_status_output=$(git -C "$repo_full_path" status --porcelain=v1 2>/dev/null)

  # Get branch name efficiently
  local branch_name
  branch_name=$(git -C "$repo_full_path" symbolic-ref --short HEAD 2>/dev/null)
  if [[ -z $branch_name ]]; then
    # Fallback for detached HEAD
    branch_name=$(git -C "$repo_full_path" describe --tags --exact-match HEAD 2>/dev/null ||
      git -C "$repo_full_path" rev-parse --short HEAD 2>/dev/null ||
      echo "-")
  fi

  local status_parts=()

  # Parse git status output and calculate statistics
  local untracked_count=0
  local modified_count=0

  while IFS= read -r line; do
    if [[ $line =~ ^\?\? ]]; then
      ((untracked_count++))
    elif [[ $line =~ ^[[:space:]]M ]]; then
      ((modified_count++))
    fi
  done <<<"$git_status_output"

  # Build statistics
  if [[ $untracked_count -gt 0 ]]; then
    status_parts+=("?${untracked_count}")
  fi
  if [[ $modified_count -gt 0 ]]; then
    status_parts+=("~${modified_count}")
  fi

  # Run diff --shortstat only when needed
  if [[ $modified_count -gt 0 ]]; then
    local shortstat
    shortstat=$(git -C "$repo_full_path" diff --shortstat 2>/dev/null)

    local insertions=0 deletions=0
    if [[ $shortstat =~ ([0-9]+)\ insertion ]]; then
      insertions="${BASH_REMATCH[1]}"
    fi
    if [[ $shortstat =~ ([0-9]+)\ deletion ]]; then
      deletions="${BASH_REMATCH[1]}"
    fi

    if [[ $insertions -gt 0 ]]; then
      status_parts+=("+${insertions}")
    fi
    if [[ $deletions -gt 0 ]]; then
      status_parts+=("-${deletions}")
    fi
  fi

  # Check special states
  local special_tags=""

  # Worktree check
  if is_worktree "$repo_full_path"; then
    special_tags+="[W]"
  fi

  # Merged branch check
  if is_branch_merged "$repo_full_path" "$branch_name"; then
    special_tags+="[M]"
  fi

  # Build output line
  local output_line
  output_line=$(printf "%-${MAX_WIDTH}s (%s)" "$repo_short_name" "$branch_name")

  # Append special tags
  if [[ -n $special_tags ]]; then
    output_line+=" $special_tags"
  fi

  if [[ ${#status_parts[@]} -gt 0 ]]; then
    local joined_status="${status_parts[*]}"
    output_line+=" $joined_status"
  fi

  echo "$output_line"
}

# Check if path is a git repository
is_git_repository() {
  local repo_path="$1"

  # .git is a directory (normal repository or main worktree)
  if [[ -d "$repo_path/.git" ]]; then
    return 0
  fi

  # .git is a file (linked worktree)
  if [[ -f "$repo_path/.git" ]]; then
    return 0
  fi

  return 1
}

# Check if path is a worktree
is_worktree() {
  local repo_path="$1"

  # .git is a file containing "gitdir:" = worktree
  if [[ -f "$repo_path/.git" ]]; then
    if grep -q "^gitdir:" "$repo_path/.git" 2>/dev/null; then
      return 0
    fi
  fi

  return 1
}

# Check if branch is merged to main/master
is_branch_merged() {
  local repo_path="$1"
  local branch_name="$2"

  # Check if main branch exists
  if git -C "$repo_path" show-ref --verify --quiet refs/heads/main; then
    local main_branch="main"
  elif git -C "$repo_path" show-ref --verify --quiet refs/heads/master; then
    local main_branch="master"
  else
    # Cannot determine if main/master doesn't exist
    return 1
  fi

  # Current branch is main/master = not merged
  if [[ "$branch_name" == "$main_branch" ]]; then
    return 1
  fi

  # Check if branch is merged
  if git -C "$repo_path" branch --merged "$main_branch" 2>/dev/null | grep -q "^\*\?\s*${branch_name}$"; then
    return 0
  fi

  return 1
}

# Process single repository (for parallel execution)
process_single_repo() {
  local repo_path="$1"
  if is_git_repository "$repo_path"; then
    get_repo_status_info "$repo_path" 2>/dev/null || {
      echo "Warning: Failed to process repository '$repo_path'" >&2
    }
  fi
}

# Get max width of repository names dynamically
MAX_WIDTH=$(ghq list | wc -L)

# Export functions for parallel processing
export -f process_single_repo
export -f get_repo_status_info
export -f is_git_repository
export -f is_worktree
export -f is_branch_merged
export GHQ_ROOT
export MAX_WIDTH

# Main loop with parallel processing

# Use temp file to collect results
TEMP_OUTPUT=$(mktemp)
trap 'rm -f "'"$TEMP_OUTPUT"'"' EXIT

# Process each repository in parallel
ghq list -p | xargs -I {} -P "$PARALLEL_JOBS" bash -c 'process_single_repo "$@"' _ {} >"$TEMP_OUTPUT"

# Sort and output results by repository name
sort "$TEMP_OUTPUT"
