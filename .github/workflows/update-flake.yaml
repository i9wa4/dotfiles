name: Update flake.lock
run-name: ${{ github.event_name }} by @${{ github.actor }}

on:
  schedule:
    # Run weekly on Friday at 06:00 UTC (15:00 JST)
    - cron: '0 6 * * 5'
  workflow_dispatch:
    inputs:
      minimum-release-age-days:
        description: 'Minimum release age in days before updating'
        required: false
        type: number
        default: 7
      skip-age-check:
        description: 'Skip the minimum release age check'
        required: false
        type: boolean
        default: false
      test-old-rev:
        description: 'Test mode: old nixpkgs rev for comparison'
        required: false
        type: string
      test-new-rev:
        description: 'Test mode: new nixpkgs rev (dry-run, no PR created)'
        required: false
        type: string

permissions: {}

defaults:
  run:
    shell: bash

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  MINIMUM_RELEASE_AGE_DAYS: ${{ github.event.inputs.minimum-release-age-days || '7' }}
  TEST_MODE: ${{ github.event.inputs.test-old-rev != '' && github.event.inputs.test-new-rev != '' }}

jobs:
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          persist-credentials: false

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@c5a866b6ab867e88becbed4467b93592bce69f8a # v21

      - name: Check release age
        id: age-check
        if: ${{ inputs.skip-age-check != true && env.TEST_MODE != 'true' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking nixpkgs release age (minimum: $MINIMUM_RELEASE_AGE_DAYS days)..."

          # Get the latest nixpkgs-unstable commit that is at least N days old
          cutoff_date=$(date -u -d "$MINIMUM_RELEASE_AGE_DAYS days ago" +%Y-%m-%dT%H:%M:%SZ)
          echo "Cutoff date: $cutoff_date"

          # Fetch commit from at least N days ago
          commit_data=$(gh api "repos/NixOS/nixpkgs/commits?sha=nixpkgs-unstable&until=${cutoff_date}&per_page=1" \
            --jq '.[0] | {sha: .sha, date: .commit.committer.date}')

          target_rev=$(echo "$commit_data" | jq -r '.sha')
          commit_date=$(echo "$commit_data" | jq -r '.date')

          if [ -z "$target_rev" ] || [ "$target_rev" = "null" ]; then
            echo "No commits found older than $MINIMUM_RELEASE_AGE_DAYS days"
            echo "should_update=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Found commit from $commit_date: ${target_rev:0:8}"
          echo "target_rev=$target_rev" >> "$GITHUB_OUTPUT"
          echo "should_update=true" >> "$GITHUB_OUTPUT"

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get old versions
        id: old-versions
        env:
          TEST_OLD_REV: ${{ github.event.inputs.test-old-rev }}
        run: |
          # Parse packages from nix files (exclude brewCasks, stdenv)
          PACKAGES=$(grep -hoE 'pkgs\.[a-zA-Z0-9_-]+' home/home.nix darwin/configuration.nix \
            | sed 's/pkgs\.//' \
            | grep -vE '^(stdenv|brewCasks)$' \
            | sort -u \
            | tr '\n' ' ')

          # Use test-old-rev if in test mode, otherwise extract from flake.lock
          if [ -n "$TEST_OLD_REV" ]; then
            NIXPKGS_REF="github:NixOS/nixpkgs/${TEST_OLD_REV}"
            echo "Test mode: using old rev ${TEST_OLD_REV:0:8}"
          else
            # Extract nixpkgs rev from flake.lock (follows root.inputs.nixpkgs reference)
            OLD_REV=$(jq -r '.nodes[.nodes.root.inputs.nixpkgs].locked.rev' flake.lock)
            NIXPKGS_REF="github:NixOS/nixpkgs/${OLD_REV}"
            echo "Using nixpkgs from flake.lock: ${OLD_REV:0:8}"
          fi

          versions=""
          for pkg in $PACKAGES; do
            ver=$(nix eval "${NIXPKGS_REF}#${pkg}.version" --raw 2>/dev/null || echo "N/A")
            versions="${versions}${pkg}=${ver}\n"
          done
          {
            echo "versions<<EOF"
            echo -e "$versions"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Update flake.lock
        if: ${{ steps.age-check.outputs.should_update != 'false' && env.TEST_MODE != 'true' }}
        env:
          TARGET_REV: ${{ steps.age-check.outputs.target_rev }}
        run: |
          if [ -n "$TARGET_REV" ]; then
            echo "Updating to nixpkgs commit: ${TARGET_REV:0:8}"
            nix flake update nixpkgs --override-input nixpkgs "github:NixOS/nixpkgs/${TARGET_REV}"
          else
            echo "Updating to latest (age check skipped)"
            nix flake update
          fi

      - name: Get new versions
        if: ${{ steps.age-check.outputs.should_update != 'false' || env.TEST_MODE == 'true' }}
        id: new-versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VERSIONS_BEFORE_UPDATE: ${{ steps.old-versions.outputs.versions }}
          TEST_NEW_REV: ${{ github.event.inputs.test-new-rev }}
        run: |
          # Parse packages from nix files (exclude brewCasks, stdenv)
          PACKAGES=$(grep -hoE 'pkgs\.[a-zA-Z0-9_-]+' home/home.nix darwin/configuration.nix \
            | sed 's/pkgs\.//' \
            | grep -vE '^(stdenv|brewCasks)$' \
            | sort -u \
            | tr '\n' ' ')

          # Use test-new-rev if in test mode, otherwise extract from updated flake.lock
          if [ -n "$TEST_NEW_REV" ]; then
            NIXPKGS_REF="github:NixOS/nixpkgs/${TEST_NEW_REV}"
            echo "Test mode: using new rev ${TEST_NEW_REV:0:8}"
          else
            # Extract nixpkgs rev from updated flake.lock
            NEW_REV=$(jq -r '.nodes[.nodes.root.inputs.nixpkgs].locked.rev' flake.lock)
            NIXPKGS_REF="github:NixOS/nixpkgs/${NEW_REV}"
            echo "Using nixpkgs from updated flake.lock: ${NEW_REV:0:8}"
          fi

          # Parse old versions (VERSIONS_BEFORE_UPDATE is set via env block)
          declare -A old_versions
          while IFS='=' read -r pkg ver; do
            [ -n "$pkg" ] && old_versions[$pkg]=$ver
          done <<< "$VERSIONS_BEFORE_UPDATE"

          # Build PR body
          pr_body="## Package Changes\n\n"
          pr_title_suffix=""
          changed_count=0

          for pkg in $PACKAGES; do
            new_ver=$(nix eval "${NIXPKGS_REF}#${pkg}.version" --raw 2>/dev/null || echo "N/A")
            old_ver="${old_versions[$pkg]:-N/A}"

            if [ "$old_ver" != "$new_ver" ]; then
              changed_count=$((changed_count + 1))
              pr_body="${pr_body}### ${pkg}: \`${old_ver}\` → \`${new_ver}\`\n\n"

              # Try to get GitHub repo from homepage or changelog
              homepage=$(nix eval "${NIXPKGS_REF}#${pkg}.meta.homepage" --raw 2>/dev/null || echo "")
              changelog=$(nix eval "${NIXPKGS_REF}#${pkg}.meta.changelog" --raw 2>/dev/null || echo "")

              github_url=""
              if [[ "$homepage" == *github.com* ]]; then
                github_url="$homepage"
              elif [[ "$changelog" == *github.com* ]]; then
                github_url="$changelog"
              fi

              echo "  ${pkg}: homepage=${homepage:-N/A}, changelog=${changelog:-N/A}"

              if [ -n "$github_url" ]; then
                owner_repo=$(echo "$github_url" | sed -E 's|https://github.com/([^/]+/[^/]+).*|\1|')
                echo "    -> GitHub repo: ${owner_repo}"

                # Fetch all releases and filter versions between old and new (Renovate-style)
                releases_json=$(gh api "repos/${owner_repo}/releases?per_page=50" 2>/dev/null || echo "[]")

                # Save releases to temp file for processing
                tmp_releases="/tmp/releases_${pkg}.txt"
                echo "$releases_json" | jq -r '.[] | "\(.tag_name)"' > "$tmp_releases"

                # Filter versions: old_ver < tag_ver <= new_ver
                matched_tags=""
                while read -r tag; do
                  [ -z "$tag" ] && continue
                  tag_ver=$(echo "$tag" | sed -E 's/^(v|release-)//')

                  # Skip if same as old version
                  [ "$tag_ver" = "$old_ver" ] && continue

                  # Check tag_ver > old_ver (old_ver should be first when sorted)
                  first=$(printf '%s\n%s' "$old_ver" "$tag_ver" | sort -V | head -1)
                  [ "$first" != "$old_ver" ] && continue

                  # Check tag_ver <= new_ver (new_ver should be last when sorted)
                  last=$(printf '%s\n%s' "$tag_ver" "$new_ver" | sort -V | tail -1)
                  [ "$last" != "$new_ver" ] && continue

                  matched_tags="${matched_tags}${tag}\n"
                done < "$tmp_releases"

                if [ -n "$matched_tags" ]; then
                  pr_body="${pr_body}<details>\n<summary>${pkg}: Release Notes (${old_ver} → ${new_ver})</summary>\n\n"

                  # Process matched releases (newest first, limit to 10)
                  echo -e "$matched_tags" | sort -V -r | head -10 | while read -r tag; do
                    [ -z "$tag" ] && continue
                    echo "    -> Found: ${tag}"
                  done

                  for tag in $(echo -e "$matched_tags" | sort -V -r | head -10); do
                    [ -z "$tag" ] && continue
                    release_body=$(echo "$releases_json" | jq -r --arg t "$tag" '.[] | select(.tag_name == $t) | .body // ""' | head -20)
                    pr_body="${pr_body}### [${tag}](https://github.com/${owner_repo}/releases/tag/${tag})\n\n"
                    pr_body="${pr_body}${release_body}\n\n"
                  done

                  pr_body="${pr_body}</details>\n\n"
                else
                  echo "    -> No release notes found, adding compare link"
                  pr_body="${pr_body}[Compare changes](https://github.com/${owner_repo}/compare/v${old_ver}...v${new_ver})\n\n"
                fi
                rm -f "$tmp_releases"
              else
                echo "    -> No GitHub URL found"
              fi

              # Build title suffix (first 3 changes)
              if [ $changed_count -le 3 ]; then
                if [ -n "$pr_title_suffix" ]; then
                  pr_title_suffix="${pr_title_suffix}, ${pkg}"
                else
                  pr_title_suffix="${pkg}"
                fi
              fi
            fi
          done

          if [ $changed_count -eq 0 ]; then
            pr_body="${pr_body}No tracked package changes.\n"
          elif [ $changed_count -gt 3 ]; then
            pr_title_suffix="${pr_title_suffix} +$((changed_count - 3)) more"
          fi

          pr_body="${pr_body}\n---\n\nAutomated flake.lock update."

          # Convert literal \n to actual newlines
          pr_body=$(echo -e "$pr_body")

          # Use HEREDOC syntax for multiline output (GitHub Actions modern format)
          {
            echo "pr_body<<EOF"
            echo "$pr_body"
            echo "EOF"
            echo "pr_title_suffix=${pr_title_suffix}"
            echo "changed_count=${changed_count}"
          } >> "$GITHUB_OUTPUT"

          # Test mode: print results and skip PR creation
          if [ -n "$TEST_NEW_REV" ]; then
            echo ""
            echo "========== TEST MODE: PR Preview =========="
            echo "Title: chore(nix): update flake.lock (${pr_title_suffix})"
            echo ""
            echo "Body:"
            echo "$pr_body"
            echo "============================================"
          fi

      - name: Check for changes
        if: ${{ steps.age-check.outputs.should_update != 'false' && env.TEST_MODE != 'true' }}
        id: check
        run: |
          if git diff --quiet flake.lock; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Create Pull Request
        if: ${{ steps.check.outputs.changed == 'true' && env.TEST_MODE != 'true' }}
        uses: peter-evans/create-pull-request@98357b18bf14b5342f975ff684046ec3b2a07725 # v8.0.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: update-flake-lock
          title: 'chore(nix): update flake.lock${{ steps.new-versions.outputs.pr_title_suffix && format('' ({0})'', steps.new-versions.outputs.pr_title_suffix) || '''' }}'
          body: ${{ steps.new-versions.outputs.pr_body }}
          labels: dependencies,automated
          delete-branch: true
